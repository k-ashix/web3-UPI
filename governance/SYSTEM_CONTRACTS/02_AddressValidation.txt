--------------------------------------------------
--------------------------------------------------
SYSTEM SNAPSHOT AUDIT HEADER
--------------------------------------------------
Snapshot Type: Implementation Reference

Aligned With:
- SEND_LIFECYCLE_CONTRACT_v1.0
- SEND_THEME_CONTRACT_v1.0

Last Alignment:
30 January 2026, 11:17:46 AM IST (+05:30)

Change Trace (High-Level):
- Clarified upstream role in Theme derivation pipeline
- Validation signaling aligned with Lifecycle gating requirements
- No internal regex or detection logic modified

Audit Notes:
- This snapshot reflects the system AFTER the above alignments
- Changes describe behavioral intent, not exact code diffs
- Snapshot body below is preserved verbatim
- No snapshot content was rewritten, reordered, or refactored
--------------------------------------------------


SUBSYSTEM CONTRACT: ADDRESS VALIDATION SYSTEM
===============================================================================
Location: src/modules/send.js (functions: validateEthereumAddress, validateBitcoinAddress,
          validateSolanaAddress, deriveValidationState, detectAssetFromAddress)
Dependencies: None
Dependents: State Management, Asset Detection, Transaction Readiness


1. SYSTEM OVERVIEW
===============================================================================
Pipeline:
Raw Address String → Format Regex → Chain Detection → Validation State → UI Gating

Address Validation System is a READ-ONLY VALIDATOR with no state mutation.

OWNS:
- Regex patterns for ETH/BTC/SOL address formats
- Chain inference logic (address → chain type)
- VALIDATION_STATE updates (via deriveValidationState)
- isAddressValid, isChainMatch, isSupportedChain flags

OBSERVES:
- APP_STATE.recipientAddress (set by address input handler)
- APP_STATE.asset (set by asset detection subsystem)
- APP_STATE.chain (derived from asset)

RESPONSIBILITY:
Determine if a wallet address is structurally valid and matches the expected
chain type. Populate VALIDATION_STATE for gating UI interactions (amounts, slider).
Do NOT validate on-chain existence or checksum (client-side heuristic only).


2. AUTHORITY MODEL
===============================================================================
NO AUTHORITATIVE STATE OWNERSHIP.

This subsystem is PURELY DERIVED.

VALIDATION_STATE authority:
- Source: APP_STATE.recipientAddress + APP_STATE.asset
- Derivation: deriveValidationState() computes flags
- Update: Object.assign(VALIDATION_STATE, newState)
- NEVER set directly by input handlers

VALIDATION FLOW:
1. User types in address input
2. Input handler updates APP_STATE.recipientAddress
3. updateValidationState() invoked
4. deriveValidationState(APP_STATE) computes new flags
5. VALIDATION_STATE updated via Object.assign
6. applyUIGating() reads VALIDATION_STATE and gates slider/amounts

MUST NEVER:
- Mutate APP_STATE from validation logic
- Write to DOM from validation functions
- Cache validation results between APP_STATE changes


3. INPUT & STATE SAFETY
===============================================================================
VALIDATION STRATEGY: Regex-based format checks (not cryptographic).

ETHEREUM VALIDATION:
Pattern: /^0x[a-fA-F0-9]{40}$/
- Must start with 0x
- Exactly 40 hex characters after prefix
- Case-insensitive (does NOT validate EIP-55 checksum)

BITCOIN VALIDATION:
Pattern: /^(1|3|bc1)[a-zA-Z0-9]{25,59}$/
- Legacy (1...), Script (3...), Segwit (bc1...)
- Length 26-60 total characters
- Does NOT validate Base58Check or Bech32 checksum

SOLANA VALIDATION:
Pattern: /^[1-9A-HJ-NP-Za-km-z]{32,44}$/
- Base58 character set (excludes 0, O, I, l)
- Length 32-44 characters
- Does NOT validate Ed25519 public key format

FORBIDDEN STATES:
- Empty address marked valid (prevented by isAddressPresent check)
- Mismatched chain (ETH address + BTC asset → isChainMatch = false)
- Unsupported chain (non-ETH/BTC/SOL → isSupportedChain = false)

WHY PREVENTION NOT CORRECTION:
Validation does NOT auto-correct invalid addresses (no "did you mean" logic).
Invalid state is surfaced via neutral UI (no green checkmark, slider disabled).
User must provide valid input; system does not guess.


4. CORE ENGINE / LOGIC CONTRACT
===============================================================================
WHAT IT DOES:

validateEthereumAddress(address):
  Returns true if matches ETH regex, false otherwise
  Pure function, no side effects

validateBitcoinAddress(address):
  Returns true if matches BTC regex, false otherwise

validateSolanaAddress(address):
  Returns true if matches SOL regex, false otherwise

detectAssetFromAddress(address):
  Returns 'eth' | 'btc' | 'sol' | null
  Precedence: ETH → BTC → SOL (order matters for overlaps)
  Edge case: SOL addresses starting with '1' or '3' → rejected (BTC collision)

deriveValidationState(appState):
  Computes:
    - isAddressPresent: !!recipientAddress && length > 0
    - isAddressValid: matches at least one chain validator
    - isSupportedChain: chain is ETH/BTC/SOL
    - isChainMatch: address matches asset's expected chain

  Returns object with 4 boolean flags

WHAT IT MUST NEVER DO:
- Make network calls to verify on-chain existence
- Validate checksums (EIP-55, Base58Check, Bech32)
- Resolve ENS domains or Unstoppable Domains
- Check address against blacklist/sanctions list
- Modify address (no normalization, no lowercase conversion)
- Cache regex results (always recompute for safety)

BOUNDARY DEFINITION:

INPUT: Raw string from address input element
VALIDATION: Regex test → boolean
OUTPUT: VALIDATION_STATE flags (isAddressValid, isChainMatch, etc.)


5. MIRRORING & DERIVATION RULES
===============================================================================
VALIDATION_STATE is FULLY DERIVED from APP_STATE.

Derivation trigger points:
1. Address input changes → updateValidationState() called
2. Asset detection completes → updateValidationState() called
   (chain may change ETH→BTC, need re-validation)

DERIVATION SEQUENCE:
APP_STATE.recipientAddress changed
  → deriveValidationState(APP_STATE)
  → returns { isAddressPresent, isAddressValid, isChainMatch, isSupportedChain }
  → Object.assign(VALIDATION_STATE, newFlags)
  → applyUIGating(VALIDATION_STATE)

WRITE BARRIERS: N/A (no writes to authoritative state)

OVERWRITE PROTECTION:
VALIDATION_STATE is Object.seal()ed to prevent accidental field addition.
Only existing fields can be updated via Object.assign.


6. UX GUARDRAILS
===============================================================================
UI FEEDBACK (passive):

Address input field:
- No address: neutral (no border color)
- Invalid address: neutral (NOT red, to avoid alarm on partial typing)
- Valid + matching chain: green border (.input-validated class)

Slider:
- Disabled if !isAddressValid || !isChainMatch || !isSupportedChain
- User attempts drag → toast: "Enter wallet address first"

Amount inputs:
- Locked (via Input Gating subsystem) if !isAddressValid

TOAST VS SILENT:
- Silent: Validation state changes (no toast spam while typing)
- Toast: User attempts gated action (slider drag, amount click)

INTENTIONAL FRICTION:
Address must be fully valid before amounts unlock.
Prevents user from entering amounts for invalid recipient (wasted effort).


7. FAILURE MODES (CONTROLLED)
===============================================================================
SILENT FAILURE (neutral state):
- Invalid address format → isAddressValid = false, UI neutral
- Chain mismatch → isChainMatch = false, UI neutral
- Unsupported chain (TRON, Cardano) → isSupportedChain = false, UI neutral

ALLOWED TO FAIL SILENTLY:
- Partial typing (user typing "0x123..." → invalid until 42 chars)
- Paste of non-address text → invalid, no error toast
- Empty address after clear → neutral state restored

NEVER FAILS HARD:
- No exceptions thrown
- No console.error (only console.warn in debug mode)
- Regex exec errors impossible (patterns are static)

DEGRADED BEHAVIOR:
If APP_STATE.chain is null (no asset detected), validation still runs.
isChainMatch will be false (expected), UI gating still applies.


8. NON-GOALS (CRITICAL)
===============================================================================
DOES NOT HANDLE:
- Checksum validation (EIP-55 for ETH, Base58Check for BTC)
- ENS/domain resolution (vitalik.eth → 0x...)
- On-chain existence verification (address may not have balance)
- Transaction history lookup
- Address blacklist/whitelist
- Sanctions compliance (OFAC, FinCEN)
- Multi-sig detection
- Contract address detection (vs EOA)
- Testnet vs mainnet disambiguation
- Cross-chain bridge addresses
- Vanity address pattern detection

WHY THESE ARE NON-GOALS:
Client-side validation is FORMAT-ONLY for UX responsiveness.
Checksum/existence checks require network calls (handled by wallet SDK in production).
Security validation (blacklists) requires backend integration (out of scope).

PRODUCTION REQUIREMENTS (not implemented):
- Server-side address validation
- OFAC/sanctions API integration
- ENS resolver integration
- Checksum verification (web3.utils.toChecksumAddress)

Current implementation is DISPLAY-LAYER only. Do NOT rely on this for security.


===============================================================================
END OF CONTRACT
===============================================================================
